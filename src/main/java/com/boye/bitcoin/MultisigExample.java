package com.boye.bitcoin;

import org.apache.commons.codec.DecoderException;
import org.bitcoinj.core.*;
import org.bitcoinj.crypto.TransactionSignature;
import org.bitcoinj.kits.WalletAppKit;
import org.bitcoinj.params.TestNet3Params;
import org.bitcoinj.script.Script;
import org.bitcoinj.script.ScriptBuilder;
import org.bitcoinj.wallet.SendRequest;
import org.bitcoinj.wallet.UnreadableWalletException;
import org.bitcoinj.wallet.Wallet;

import java.io.File;
import java.io.IOException;
import java.sql.SQLOutput;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.ExecutionException;

import static com.google.common.base.Preconditions.checkState;

/*
 * This Java source file was generated by the Gradle 'init' task.
 */
public class MultisigExample {
    private TestNet3Params params = TestNet3Params.get();
    private WalletAppKit appKit = null;
    private ECKey keyA = new ECKey();
    private ECKey keyB = new ECKey();
    private ECKey keyC = new ECKey();

    private Script payingToMultisigTxoutScript = null;

    private Transaction payingToMultisigTx = null;
    private TransactionOutput multisigOutput =  null;
    private Transaction redeemingMultisigTx1 = null;
    private Transaction redeemingMultisigTx2 = null;
    private TransactionInput redeemMultisigTxInput = null;


    private ECKey.ECDSASignature partyASignature =null;

    private  void createMultisigAddress(){
        List<ECKey> keyList = Arrays.asList(keyA, keyB, keyC);
        payingToMultisigTxoutScript = ScriptBuilder.createMultiSigOutputScript(2, keyList); //2 of 3 multisig
    }
    private  void sendCoinsToMultisigAddress() throws InsufficientMoneyException, ExecutionException, InterruptedException {
        Wallet wallet= appKit.wallet();
        payingToMultisigTx = new Transaction(params);
        Coin value = Coin.valueOf(0,10); // 0.1 btc
        payingToMultisigTx.addOutput(value, payingToMultisigTxoutScript);
        SendRequest request = SendRequest.forTx(payingToMultisigTx);
        wallet.completeTx(request); // fill in coins
        PeerGroup peerGroup = appKit.peerGroup();
        peerGroup.broadcastTransaction(request.tx).broadcast().get();
        System.out.println("Paying to multisig transaction broadcasted!");
        System.out.println("Wallet's current receive address: " + wallet.currentReceiveAddress());
        System.out.println("Wallet contents: " + wallet);
    }

    private  void createRawTransactionForMultisigRedeemingByA(){
        redeemingMultisigTx1 = new Transaction(params);
        TransactionOutput multisigOutput = payingToMultisigTx.getOutput(0);
        redeemingMultisigTx1.addInput(multisigOutput);
        Coin value = multisigOutput.getValue();
        Wallet wallet = appKit.wallet();
        redeemingMultisigTx1.addOutput(value, wallet.currentReceiveAddress());

    }

    private  void signRawTransactionForMultisigRedeemingByA(){
        Script payingToMultisigTxoutScriptPubKey = multisigOutput.getScriptPubKey();
        checkState(payingToMultisigTxoutScriptPubKey.isSentToMultiSig());
        Sha256Hash sighash = redeemingMultisigTx1.hashForSignature(0, payingToMultisigTxoutScriptPubKey, Transaction.SigHash.ALL, false);
        ECKey.ECDSASignature partyASignature = keyA.sign(sighash);
    }

    private  void createRawTransactionForMultisigRedeemingByB(){
        Transaction redeemingMultisigTx2 = new Transaction(params);
        TransactionOutput multisigOutput = payingToMultisigTx.getOutput(0);
        TransactionInput input =redeemingMultisigTx2.addInput(multisigOutput);
        Coin value = multisigOutput.getValue();
        Wallet wallet = appKit.wallet();
        redeemingMultisigTx2.addOutput(value,  wallet.currentReceiveAddress());


    }

    private  void signRawTransactionForMultisigRedeemingByB() throws ExecutionException, InterruptedException {
        Script payingToMultisigTxoutScriptPubKey = multisigOutput.getScriptPubKey();
        Sha256Hash sighash = redeemingMultisigTx2.hashForSignature(0, payingToMultisigTxoutScriptPubKey, Transaction.SigHash.ALL, false);
        ECKey.ECDSASignature mySignature = keyB.sign(sighash);
        Script inputScript = ScriptBuilder.createMultiSigInputScript((TransactionSignature) mySignature, (TransactionSignature) partyASignature);
        redeemMultisigTxInput.setScriptSig(inputScript);
        redeemMultisigTxInput.verify(multisigOutput);
    }
    private void broadcastMultisigRedeemingTx() throws ExecutionException, InterruptedException {
        PeerGroup peerGroup = appKit.peerGroup();
        peerGroup.broadcastTransaction(redeemingMultisigTx2).broadcast().get();
        System.out.println("Multisig redeeming transaction broadcasted!");
        Wallet wallet =  appKit.wallet();
        System.out.println("Wallet's current receive address: " + wallet.currentReceiveAddress());
        System.out.println("Wallet contents: " + wallet);
    }

    private void prepareCoins(){
        appKit = new WalletAppKit(params, new File("."), "wallet1"); //The wallet is not to be created twice.
        appKit.startAsync();
        appKit.awaitRunning();
        System.out.println("Network connected!");
        Wallet wallet =  appKit.wallet();
        System.out.println("Wallet's current receive address: " + wallet.currentReceiveAddress());
        System.out.println("Wallet contents: " + wallet);
    }

    public static void main(String[] args) throws InsufficientMoneyException, ExecutionException, InterruptedException {
            MultisigExample example = new MultisigExample();
            example.prepareCoins();
            example.createMultisigAddress();
            example.sendCoinsToMultisigAddress();
            example.createRawTransactionForMultisigRedeemingByA();
            example.signRawTransactionForMultisigRedeemingByA();
            example.createRawTransactionForMultisigRedeemingByB();
            example.signRawTransactionForMultisigRedeemingByB();
            example.broadcastMultisigRedeemingTx();
    }
}
